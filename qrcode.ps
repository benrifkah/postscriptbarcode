%!PS

/barcode (01234567) def
/eclevel (unset) def
/version (unset) def

        /barlen barcode length def
        eclevel (unset) eq {/eclevel (M) def} if

        % Determine smallest symbol version to hold given amount of numeric data
        version (unset) eq {
            /caps [
                [
                      41    77   127   187   255   322   370   461   552   652   % 1-L  - 10-L
                     772   883  1022  1101  1250  1408  1548  1725  1903  2061   % 11-L - 20-L
                    2232  2409  2620  2812  3057  3283  3517  3669  3909  4158   % 21-L - 30-L
                    4417  4686  4965  5253  5529  5836  6153  6479  6743  7089   % 31-L - 40-L
                ] [
                      34    63   101   149   202   255   293   365   432   513   % 1-M  - 10-M
                     604   691   796   871   991  1082  1212  1346  1500  1600   % 11-M - 20-M
                    1708  1872  2059  2188  2395  2544  2701  2857  3035  3289   % 21-M - 30-M
                    3486  3693  3909  4134  4343  4588  4775  5039  5313  5596   % 31-M - 40-M
                ] [
                      27    48    77   111   144   178   207   259   312   364   % 1-Q  - 10-Q
                     427   489   580   621   703   775   876   948  1063  1159   % 11-Q - 20-Q
                    1224  1358  1468  1588  1718  1804  1933  2085  2181  2358   % 21-Q - 30-Q
                    2473  2670  2805  2949  3081  3244  3417  3599  3791  3993   % 31-Q - 40-Q
                ] [
                      17    34    58    82   106   139   154   202   235   288   % 1-H  - 10-H
                     331   374   427   468   530   602   674   746   813   919   % 11-H - 20-H
                     969  1056  1108  1228  1286  1425  1501  1581  1677  1782   % 21-H - 30-H
                    1897  2022  2157  2301  2361  2524  2625  2735  2927  3057   % 31-H - 40-H
                ]
            ] def
            /caps caps (LMQH) eclevel search pop length exch pop exch pop get def
            /i 1 def
            {
                barlen caps i 1 sub get le {exit} if 
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
        } if

        % Set the control character data for the version
        /mid (0001) def /term (0000) def /cclen 10 def
        version 0 1 getinterval (M) ne {  % Version 10 and above
            version cvi 10 ge {/cclen 12 def} if
            version cvi 27 ge {/cclen 14 def} if
        } if
        /midlen mid length def
        /termlen term length def

        % Create the bitstream as numeric_mode_id character_count bitstream term
        /msgbits midlen cclen add barlen 8 mul add termlen add string def
        msgbits 0 mid putinterval
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen cvi 2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        msgbits midlen cc putinterval

/msg barlen 10 mul 3 idiv 1 add string def
/i 0 def /j 0 def {
  i barlen eq {exit} if
  i barlen 2 sub lt {
    (0000000000) 10 string copy
    dup barcode i 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
    /i i 3 add def
  } {
    i barlen 2 sub eq {  % Two final digits
      (0000000) 7 string copy
      dup barcode i 2 getinterval cvi 2 7 string cvrs dup length 7 exch sub exch putinterval
      /i i 2 add def
    } {  % One final digit
      (0000) 4 string copy
      dup barcode i 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
      /i i 1 add def
    } ifelse
  } ifelse
  dup msg exch j exch putinterval
  length j add /j exch def
} loop
/msg msg 0 j getinterval def

        msgbits midlen cclen add barlen 8 mul add term putinterval
